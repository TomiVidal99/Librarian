import {
  app,
  BrowserWindow,
  dialog,
  ipcMain,
  IpcMainEvent,
  shell,
} from "electron";
import {
  IDestinationFolder,
  IFilter,
  INotification,
  IPC_CALLS,
} from "./models";
import {
  getState,
  resetState,
  saveState,
  updateOriginListeners,
  initalizeWatcher,
  removeAllListeners,
  removeFoldersListeners,
  createTray,
  destroyTray,
  cleanTrayAnimations,
  sendNotification,
  disableAutoLaunch,
  enableAutoLaunch,
  setLanguage,
  updateTrayText,
  initializeStore,
  getCurrentLanguage,
  getTranslated,
  LanguageType,
  fileExits,
} from "./utils";
import { IGlobalState } from "./state";
import { FSWatcher } from "chokidar";
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
//
// This constant is only defined if a bundle for preload has been generated. In order to get it generated,
// preload needs to be defined as entry point. E.g. add
// "preload": { "js": "./src/preload.ts" }
// to the "entryPoints" in your package.json.
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const FILTERS_WINDOW_WEBPACK_ENTRY: string;

let watcher: FSWatcher;

let settingsWindow: BrowserWindow = null;
let filtersWindow: BrowserWindow = null;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

const createSettingsWindow = (): void => {
  // Create the browser window.
  settingsWindow = new BrowserWindow({
    height: 600,
    width: 800,
    show: false,
    frame: process.env.NODE_ENV === "development",
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // and load the index.html of the app.
  settingsWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // loads the saved state
  settingsWindow.on("ready-to-show", () => {
    // send state to the page
    settingsWindow.webContents.send(IPC_CALLS.GET_STATE_FROM_MAIN, getState());
  });

  settingsWindow.on("close", (event) => {
    event.preventDefault();
    settingsWindow.hide();
  });
};
// toggle open or closed the mainWindow when the tray it's double clicked
// or when the option in the drop down menu it's clicked
// TODO: add menu option to open the settings window
// TODO: replace hide and show with destroy and create.
export const toggleOpenMainWindow = () => {
  if (!settingsWindow) throw "Expected mainWindow to exits.";
  settingsWindow.isVisible() ? settingsWindow.hide() : settingsWindow.show();
};

const createFiltersWindow = (): void => {
  // check if the window has already been created
  if (filtersWindow !== null) {
    filtersWindow.focus();
    return;
  }

  // Create the browser window.
  filtersWindow = new BrowserWindow({
    height: 600,
    width: 200,
    frame: process.env.NODE_ENV === "development",
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // and load the index.html of the app.
  filtersWindow.loadURL(FILTERS_WINDOW_WEBPACK_ENTRY);

  // send state to the page
  filtersWindow.on("ready-to-show", () => {
    filtersWindow.webContents.send(IPC_CALLS.GET_STATE_FROM_MAIN, getState());
  });

  filtersWindow.on("closed", () => {
    filtersWindow = null;
  });

  // Open the DevTools.
  // filtersWindow.webContents.openDevTools();
};

export interface ISendRecentlyWatchedFolder {
  name: string;
  origin: string;
  destination: string;
  filter: IFilter;
}
/**
 * Sends data to the settings page to make a recently moved folder.
 */
export const sendRecentlyWatchedFolder = (data: ISendRecentlyWatchedFolder) => {
  if (settingsWindow === null) return;
  settingsWindow.webContents.send(IPC_CALLS.SEND_RECENTLY_WATCHED, data);
};

async function initApp() {
  // TODO: if the window has not been created and a folder has been
  // the recently moved folder won't be created.
  //createSettingsWindow();

  initializeStore();

  await setLanguage(getState().language);

  createTray();

  // creates the main window
  createSettingsWindow();

  // start watching
  watcher = initalizeWatcher();

  // init auto launcher
  if (getState().autoLaunch) {
    enableAutoLaunch();
  }
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", initApp);

// Quit app
export const quitApp = () => {
  app.quit();
};

// Clean before quitting
app.on("before-quit", () => {
  removeAllListeners({ watcher });
  settingsWindow.destroy();
  filtersWindow.destroy();
  cleanTrayAnimations();
  destroyTray();
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createSettingsWindow();
  }
});

// Create the settings window when the user clicks the add destination folder button
ipcMain.on(IPC_CALLS.OPEN_FILTERS_WINDOW, () => {
  createFiltersWindow();
});

// Open folders
ipcMain.handle(
  IPC_CALLS.OPEN_FOLDERS_DIALOG,
  async (
    _: IpcMainEvent,
    multiSelection: boolean
    // callback: (arg0: string[]) => void,
    // multiSelection: boolean
  ) => {
    const dir = await dialog.showOpenDialog({
      properties: ["openDirectory", multiSelection ? "multiSelections" : null],
    });
    const dirPath = dir.filePaths;
    return dirPath;
  }
);

// opens a window with a warning message
ipcMain.on(
  IPC_CALLS.POP_WARNING_MESSAGE,
  (_: IpcMainEvent, data: { title: string; body: string }) => {
    dialog.showMessageBox(settingsWindow, {
      message: data.body,
      title: data.title,
    });
    // const not = new Notification({ title: data.title, body: data.body });
    // not.show();
  }
);

// sends a new destination folder from the filters window to the main window
ipcMain.on(
  IPC_CALLS.SEND_FOLDER_FROM_FILTERS_WINDOW,
  (_: IpcMainEvent, folder: IDestinationFolder) => {
    if (folder.name === "") return;
    settingsWindow.webContents.send(IPC_CALLS.RECIEVE_FOLDER_FROM_MAIN, folder);
  }
);

// gets the new updated state from the settings window
ipcMain.on(
  IPC_CALLS.SEND_STATE_FROM_SETTINGS_TO_MAIN,
  (_: IpcMainEvent, state: IGlobalState) => {
    saveState(state);
    updateOriginListeners({ watcher });
    // updates the state of the filters window
    if (filtersWindow && !filtersWindow.isDestroyed()) {
      filtersWindow.webContents.send(
        IPC_CALLS.GET_STATE_FROM_SETTINGS_WINDOW,
        state
      );
    }
  }
);

// resets the settings
ipcMain.on(IPC_CALLS.RESET_SETTINGS, () => {
  settingsWindow.webContents.send(IPC_CALLS.GET_STATE_FROM_MAIN, resetState());
  watcher.removeAllListeners();
});

// open recently moved file folder
ipcMain.on(
  IPC_CALLS.OPEN_RECENTLY_MOVED_FOLDER,
  (_: IpcMainEvent, folder: string) => {
    fileExits(folder)
      .then((fileStillExists) => {
        if (!fileStillExists) {
          const title = getTranslated(
            "recentlyMovedFileNoLongerExistsTitleWarning"
          );
          const body = getTranslated(
            "recentlyMovedFileNoLongerExistsBodyWarning"
          );
          dialog.showMessageBox(settingsWindow, {
            message: body
              .replace("%folderpath", folder)
              .replace(/^\w/, (c) => c.toUpperCase()),
            title: title.replace(/^\w/, (c) => c.toUpperCase()),
          });
        }
      })
      .catch((err) => {
        if (err) throw err;
      });
    shell.showItemInFolder(folder);
  }
);

// return the current origin folders being watched
ipcMain.handle(IPC_CALLS.GET_ORIGIN_FOLDERS, async () => {
  return watcher.getWatched();
});

// removes listeners from the removed origin folder
ipcMain.on(
  IPC_CALLS.REMOVE_ORIGIN_FOLDER,
  (_: IpcMainEvent, folders: string[]) => {
    removeFoldersListeners({ watcher, folders });
  }
);

// sends a notification to the system
ipcMain.on(
  IPC_CALLS.SEND_NOTIFICATION,
  (_: IpcMainEvent, data: INotification) => {
    sendNotification(data);
  }
);

// enables/disables auto launch
ipcMain.on(IPC_CALLS.TOGGLE_AUTO_LAUNCH, (_: IpcMainEvent, enable: boolean) => {
  console.log({ enable });
  if (enable) {
    enableAutoLaunch();
  } else {
    disableAutoLaunch();
  }
});

// changes the language
ipcMain.on(
  IPC_CALLS.CHANGE_LANGUAGE,
  async (_: IpcMainEvent, lang: LanguageType) => {
    await setLanguage(lang);
    updateTrayText();
    settingsWindow.webContents.send(
      IPC_CALLS.GET_LANGUAGE,
      getCurrentLanguage()
    );
  }
);

// send translation to the renderer
ipcMain.on(IPC_CALLS.SEND_LANGUAGE_TO_RENDERER, () => {
  settingsWindow.webContents.send(IPC_CALLS.GET_LANGUAGE, getCurrentLanguage());
});
