import {
  app,
  BrowserWindow,
  dialog,
  ipcMain,
  IpcMainEvent,
  shell,
} from "electron";
import {
  IDestinationFolder,
  IFilter,
  INotification,
  IPC_CALLS,
} from "./models";
import Store from "electron-store";
import {
  getState,
  resetState,
  saveState,
  updateOriginListeners,
  initalizeWatcher,
  removeAllListeners,
  removeFoldersListeners,
  createTray,
  destroyTray,
  cleanTrayAnimations,
} from "./utils";
import { IGlobalState } from "./state";
import { FSWatcher } from "chokidar";
import { sendNotification } from "./utils/handle-notifications.utils";
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
//
// This constant is only defined if a bundle for preload has been generated. In order to get it generated,
// preload needs to be defined as entry point. E.g. add
// "preload": { "js": "./src/preload.ts" }
// to the "entryPoints" in your package.json.
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const FILTERS_WINDOW_WEBPACK_ENTRY: string;

// const BASE_APP_PATH = "file://" + path.join(__dirname, "/../renderer/main_window");
// const MAIN_WINDOW_WEBPACK_ENTRY =
//   process.env.NODE_ENV === "production"
//     ? path.join(BASE_APP_PATH, "/index.html") + "/main_window"
//     : "http://localhost:3000/main_window";
// const FILTERS_WINDOW_WEBPACK_ENTRY =
//   process.env.NODE_ENV === "production"
//     ? path.join(BASE_APP_PATH, "index.html/filters_window")
//     : "http://localhost:3000/filters_window";

let watcher: FSWatcher;
export const store = new Store();

let settingsWindow: BrowserWindow = null;
let filtersWindow: BrowserWindow = null;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

const createSettingsWindow = (): void => {
  // Create the browser window.
  settingsWindow = new BrowserWindow({
    height: 600,
    width: 800,
    show: false,
    frame: process.env.NODE_ENV === "development",
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // and load the index.html of the app.
  settingsWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // loads the saved state
  settingsWindow.on("ready-to-show", () => {
    // send state to the page
    settingsWindow.webContents.send(
      IPC_CALLS.GET_STATE_FROM_MAIN,
      getState(store)
    );
  });

  settingsWindow.on("close", (event) => {
    event.preventDefault();
    settingsWindow.hide();
  });
};
// toggle open or closed the mainWindow when the tray it's double clicked
// or when the option in the drop down menu it's clicked
// TODO: add menu option to open the settings window
export const toggleOpenMainWindow = () => {
  if (!settingsWindow) throw "Expected mainWindow to exits.";
  settingsWindow.isVisible() ? settingsWindow.hide() : settingsWindow.show();
};

const createFiltersWindow = (): void => {
  // check if the window has already been created
  if (filtersWindow !== null) {
    filtersWindow.focus();
    return;
  }

  // Create the browser window.
  filtersWindow = new BrowserWindow({
    height: 600,
    width: 200,
    frame: process.env.NODE_ENV === "development",
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // and load the index.html of the app.
  filtersWindow.loadURL(FILTERS_WINDOW_WEBPACK_ENTRY);

  // send state to the page
  filtersWindow.on("ready-to-show", () => {
    filtersWindow.webContents.send(
      IPC_CALLS.GET_STATE_FROM_MAIN,
      getState(store)
    );
  });

  filtersWindow.on("closed", () => {
    filtersWindow = null;
  });

  // Open the DevTools.
  // filtersWindow.webContents.openDevTools();
};

export interface ISendRecentlyWatchedFolder {
  name: string;
  origin: string;
  destination: string;
  filter: IFilter;
}
/**
 * Sends data to the settings page to make a recently moved folder.
 */
export const sendRecentlyWatchedFolder = (data: ISendRecentlyWatchedFolder) => {
  if (settingsWindow === null) return;
  settingsWindow.webContents.send(IPC_CALLS.SEND_RECENTLY_WATCHED, data);
};

function initApp() {
  // TODO: if the window has not been created and a folder has been
  // the recently moved folder won't be created.
  //createSettingsWindow();
  createTray();

  // creates the main window
  createSettingsWindow();

  // start watching
  watcher = initalizeWatcher();
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", initApp);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
// app.on("window-all-closed", () => {
//   if (process.platform !== "darwin") {
//     if (watcher) {
//       removeAllListeners({ watcher });
//     }
//     app.quit();
//   }
// });

// Quit app
export const quitApp = () => {
  app.quit();
};

// Clean before quitting
app.on("before-quit", () => {
  removeAllListeners({ watcher });
  settingsWindow.destroy();
  filtersWindow.destroy();
  cleanTrayAnimations();
  destroyTray();
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createSettingsWindow();
  }
});

// Create the settings window when the user clicks the add destination folder button
ipcMain.on(IPC_CALLS.OPEN_FILTERS_WINDOW, () => {
  createFiltersWindow();
});

// Open folders
ipcMain.handle(
  IPC_CALLS.OPEN_FOLDERS_DIALOG,
  async (
    event: IpcMainEvent,
    multiSelection: boolean
    // callback: (arg0: string[]) => void,
    // multiSelection: boolean
  ) => {
    const dir = await dialog.showOpenDialog({
      properties: ["openDirectory", multiSelection ? "multiSelections" : null],
    });
    const dirPath = dir.filePaths;
    return dirPath;
  }
);

// opens a window with a warning message
ipcMain.on(
  IPC_CALLS.POP_WARNING_MESSAGE,
  (event: IpcMainEvent, data: { title: string; body: string }) => {
    dialog.showMessageBox(settingsWindow, {
      message: data.body,
      title: data.title,
    });
    // const not = new Notification({ title: data.title, body: data.body });
    // not.show();
  }
);

// sends a new destination folder from the filters window to the main window
ipcMain.on(
  IPC_CALLS.SEND_FOLDER_FROM_FILTERS_WINDOW,
  (event: IpcMainEvent, folder: IDestinationFolder) => {
    if (folder.name === "") return;
    settingsWindow.webContents.send(IPC_CALLS.RECIEVE_FOLDER_FROM_MAIN, folder);
  }
);

// gets the new updated state from the settings window
ipcMain.on(
  IPC_CALLS.SEND_STATE_FROM_SETTINGS_TO_MAIN,
  (event: IpcMainEvent, state: IGlobalState) => {
    saveState(store, state);
    updateOriginListeners({ watcher });
    // updates the state of the filters window
    if (filtersWindow && !filtersWindow.isDestroyed()) {
      filtersWindow.webContents.send(IPC_CALLS.GET_STATE_FROM_SETTINGS_WINDOW, state);
    }
  }
);

// resets the settings
ipcMain.on(IPC_CALLS.RESET_SETTINGS, () => {
  settingsWindow.webContents.send(
    IPC_CALLS.GET_STATE_FROM_MAIN,
    resetState(store)
  );
  watcher.removeAllListeners();
});

// open recently moved file folder
ipcMain.on(
  IPC_CALLS.OPEN_RECENTLY_MOVED_FOLDER,
  (event: IpcMainEvent, folder: string) => {
    shell.showItemInFolder(folder);
  }
);

// return the current origin folders being watched
ipcMain.handle(IPC_CALLS.GET_ORIGIN_FOLDERS, async () => {
  return watcher.getWatched();
});

// removes listeners from the removed origin folder
ipcMain.on(
  IPC_CALLS.REMOVE_ORIGIN_FOLDER,
  (event: IpcMainEvent, folders: string[]) => {
    removeFoldersListeners({ watcher, folders });
  }
);

// sends a notification to the system
ipcMain.on(
  IPC_CALLS.SEND_NOTIFICATION,
  (event: IpcMainEvent, data: INotification) => {
    sendNotification(data);
  }
);
